;--------------------------------------------------------
; File Created by SDCC : free open source ANSI-C Compiler
; Version 3.0.1 #6227 (Oct 24 2011) (CYGWIN)
; This file was generated Mon Oct  7 21:54:33 2019
;--------------------------------------------------------
;--------------------------------------------------------
; global & static initialisations
;--------------------------------------------------------
	CONSTANT	_intcon, 00
	CONSTANT	_tmr_flag, 01

	;	../common/bamse.h:42: volatile unsigned char intcon = 0;
	LOAD	s0, 00
	STORE	s0, _intcon
	LOAD	sF, 3f
	JUMP	__sdcc_program_startup
;--------------------------------------------------------
; Home
;--------------------------------------------------------
__sdcc_program_startup:
	CALL	_main
;	return from main will lock up
__sdcc_loop:
	JUMP	__sdcc_loop
;--------------------------------------------------------
; code
;--------------------------------------------------------
	;	../common/bamse.h:49: void intcon_enable_bits(unsigned char pos)
_intcon_enable_bits:
	LOAD	s0, sB
	;	../common/bamse.h:52: aux = intcon;
	FETCH	s1, _intcon
	;	../common/bamse.h:54: aux |= pos;	 
	OR	s0, s1
	;	../common/bamse.h:55: PBLAZEPORT[INT_OUT_CONFIG] = aux;
	OUTPUT	s0, 00
	;	../common/bamse.h:57: intcon = aux;	
	STORE	s0, _intcon
	RETURN
	;	../common/bamse.h:60: void intcon_disable_bits(unsigned char pos)
_intcon_disable_bits:
	LOAD	s0, sB
	;	../common/bamse.h:64: aux = intcon;
	FETCH	s1, _intcon
	;	../common/bamse.h:66: aux &= (~pos);	
	XOR	s0, ff
	AND	s0, s1
	;	../common/bamse.h:67: PBLAZEPORT[INT_OUT_CONFIG] = aux;
	OUTPUT	s0, 00
	;	../common/bamse.h:69: intcon = aux;
	STORE	s0, _intcon
	RETURN
	;	device/include/pblaze/intr.h:30: void pbcc_enable_interrupt(void)
_pbcc_enable_interrupt:
	;	device/include/pblaze/intr.h:34: __endasm;
	       ENABLE INTERRUPT
	RETURN
	;	device/include/pblaze/intr.h:37: void pbcc_disable_interrupt(void)
_pbcc_disable_interrupt:
	;	device/include/pblaze/intr.h:41: __endasm;
	;
	      DISABLE INTERRUPT
	RETURN
	;	../common/timer.h:17: void TIMER_setCounter(unsigned short count)
_TIMER_setCounter:
	LOAD	s0, sB
	LOAD	s1, sC
	;	../common/timer.h:21: aux = (unsigned char)(count);
	LOAD	s2, s0
	;	../common/timer.h:22: PBLAZEPORT[TIMER_LREG] = aux;
	OUTPUT	s2, 0b
	;	../common/timer.h:24: aux = (unsigned char)(count >> 8);
	LOAD	s3, s1
	LOAD	s4, 01
	;	../common/timer.h:25: PBLAZEPORT[TIMER_HREG] = aux;
	OUTPUT	s3, 0c
	RETURN
	;	../common/timer.h:28: void TIMER_setConf(unsigned char conf)
_TIMER_setConf:
	LOAD	s0, sB
	;	../common/timer.h:30: PBLAZEPORT[TIMER] = conf;	
	OUTPUT	s0, 0a
	RETURN
	;	../common/timer.h:33: unsigned char TIMER_readConf()
_TIMER_readConf:
	;	../common/timer.h:37: aux = PBLAZEPORT[TIMER];
	INPUT	s0, 0a
	;	../common/timer.h:38: return aux;
	LOAD	sB, s0
	RETURN
	;	test_timer.c:9: void main()
_main:
	;	test_timer.c:13: tmr_flag = 0;
	LOAD	s0, 00
	STORE	s0, _tmr_flag
	;	test_timer.c:15: TIMER_setCounter(0x0000);
	LOAD	sB, 00
	LOAD	sC, 00
	CALL	_TIMER_setCounter
	;	test_timer.c:18: TIMER_setConf(aux);
	LOAD	sB, 7e
	CALL	_TIMER_setConf
	;	test_timer.c:22: intcon_enable_bits(aux);
	LOAD	sB, 20
	CALL	_intcon_enable_bits
	;	test_timer.c:24: pbcc_enable_interrupt();
	CALL	_pbcc_enable_interrupt
	;	test_timer.c:26: flip = 0;
	LOAD	s0, 00
	;	test_timer.c:27: while(1) {
_L00121:
	;	test_timer.c:35: if (tmr_flag) {			
	FETCH	s1, _tmr_flag
	COMPARE	s1, 00
	JUMP	NZ, _LC00133
	JUMP	_L00121
_LC00133:
	;	test_timer.c:36: tmr_flag = 0;
	LOAD	s2, 00
	STORE	s2, _tmr_flag
	;	test_timer.c:38: if (flip) {
	COMPARE	s0, 00
	JUMP	NZ, _LC00134
	JUMP	_L00116
_LC00134:
	;	test_timer.c:39: flip = 0;
	LOAD	s0, 00
	;	test_timer.c:40: PBLAZEPORT[PORTC_OUT] = 0x00;
	LOAD	s2, 00
	OUTPUT	s2, 05
	JUMP	_L00121
_L00116:
	;	test_timer.c:42: flip = 1;			
	LOAD	s0, 01
	;	test_timer.c:43: PBLAZEPORT[PORTC_OUT] = 0xff;
	LOAD	s2, ff
	OUTPUT	s2, 05
	JUMP	_L00121
	;	test_timer.c:50: void _interrupt_handler(void) __interrupt (1)
_interrupt_handler:
	;	test_timer.c:54: flags = PBLAZEPORT[INT_IN_FLAGS];
	STORE	s0, (sF)
	SUB	sF, 01
	INPUT	s0, 00
	STORE	s1, (sF)
	SUB	sF, 01
	LOAD	s1, s0
	;	test_timer.c:56: if (flags & TIMER_INT_FLAG_BIT) {
	LOAD	s0, s1
	AND	s0, 20
	COMPARE	s0, 00
	JUMP	NZ, _LC00135
	JUMP	_L00130
_LC00135:
	;	test_timer.c:57: aux = TIMER_readConf();
	CALL	_TIMER_readConf
	LOAD	s0, sB
	STORE	s2, (sF)
	SUB	sF, 01
	LOAD	s2, s0
	;	test_timer.c:58: aux &= 0b11111110; // Clear interrupt flag
	LOAD	s0, s2
	STORE	s3, (sF)
	SUB	sF, 01
	LOAD	s3, s0
	AND	s3, fe
	LOAD	s2, s3
	;	test_timer.c:60: TIMER_setConf(aux);		
	LOAD	s0, s2
	LOAD	sB, s0
	CALL	_TIMER_setConf
	;	test_timer.c:61: tmr_flag = 1;				
	LOAD	s0, 01
	STORE	s0, _tmr_flag
_L00130:
	ADD	sF, 01
	FETCH	s3, (sF)
	ADD	sF, 01
	FETCH	s2, (sF)
	ADD	sF, 01
	FETCH	s1, (sF)
	ADD	sF, 01
	FETCH	s0, (sF)
	RETURNI ENABLE
;--------------------------------------------------------
; interrupt vector 
;--------------------------------------------------------
	ADDRESS	3ff
	JUMP	_interrupt_handler
